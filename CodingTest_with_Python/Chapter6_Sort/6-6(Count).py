# Count Sort 계수 정렬
# 특정한 조건이 부합될 떄만 사용 가능하지만 매우 빠른 알고리즘
# 조건만 부합한다면 Radix Sort(기수 정렬)과 더불어 가장 빠름
# 기수 정렬은 조금 더 느리지만 처리 범위가 더 큼

# 장점 : 양의 데이터가 N개 최댓값이 K일때 계수정렬은 최악에도 O(N+K)를 보장
# 단점 : 데이터의 크기 범위가 제한되어 정수 형태로만 표현 가능할 때 사용가능
# + 가장 큰, 가장 작은 데이터 차이가 너무 크면 사용 불가
# ex. 실수형 데이터 사용 어려움, 작은, 큰 데이터의 차이가 1,000,000을 넘지 않을때 효과적

# 모든 범위를 담을 수 있는 크기의 리스트(배열) 선언 필요
# 가장큰데이터가 100 이면 총 101개 ( 0 까지 포함 )
# 앞의 선택, 삽입, 퀵 처럼 비교기반 정렬 알고리즘이 아님

'''
 해당 INDEX의 배열에 값을 1 추가하는 방식으로 적용
 완료된 배열을 순서대로 출력
'''
array = [7,5,9,0,3,1,6,2,9,1,4,8,0,5,2]

# 최대 값 + 1을 생성하여 0~최대값 Value = 0
count = [0] * (max(array)+1)

for i in range(len(array)):
    count[array[i]] += 1

for i in range(len(count)):
    for j in range(count[i]):
        print(i, end=' ') # 띄어쓰기를 구분으로 등장한 횟수만큼 출력



# 공간 복잡도는 배열의 크기만 큼이기 때문에 O(N+K)
